.data
	sequence: .space 100					#light sequence generated by simon
.text

wait: 	
	beq $t9, $zero, wait					#wait for user to hit start button to begin
	addi $t8, $zero, 16
	addi $t9, $zero, 0					#reset value of $t9
	
	la $s0, sequence					#store address of simon sequence in $s0
	
	addi $s4, $zero, 0					#set shift amount to zero
	
	addi $v0, $zero, 30					#store time in $a0
	syscall
	
genRand:
	addi $v0, $zero, 42					#store random # between 0 and 4 in $s1
	addi $a1, $zero, 4	
	syscall
	add $s1, $a0, $zero
	
	addi $s2, $zero, 1					#make register s2 1
	sllv $s3, $s2, $s1					#shift s2 left by the number stored in s1, used to convert a rand # into simon instruction
	
	add $t0, $s4, $s0					#scale array address by adding the initial address and a shift amount
	sb $s3, 0($t0)						#store new instruction in next index
	
	addi $s4, $s4, 4					#increment shift amount
	
	j display
	
display:
	add $t1, $zero, 0					#initially set #t1 to zero
	addi $s5, $zero, 0					#set read address to zero
	
	displayLoop:
		add $t1, $s5, $s0				#get address to read and load the byte
		lb $t2, 0($t1)					#load byte of address into t2
		add $t8, $t2, $zero				#make $t8 equal $t2 because t8 gets automatically reset
		beq $t2, 0, getInput				#if t2 is zero(end of sequence), go to next step
		addi $s5, $s5, 4				#if t2 is not zero, increment address to read and loop
		j displayLoop
			
getInput:
	addi $t4, $zero, 0					#initiallize temp counter to 0
	add $t5, $zero, $s0					#load address of next instruction into t5
	
	inputWait: 	
		beq $t9, $zero, inputWait			#wait for user to hit a button to begin
		add $t8 $t9, $zero				#give user feedback as to what they press
	inputLoop:
		lbu $t6, 0($t5)					#load input from sequence and check for equality
		bne $t9, $t6, end
		addi $t5, $t5, 4				#increment read address
		addi $t9, $zero, 0				#reset $t9
		lbu $t7, 0($t5)					#test if next instruction is 0, if it is generate a new #
		beq $t7, 0, genRand				
		j inputWait					#get another input if the user was right	
end:
	addi $t8, $zero, 15					#set t8 to end sequence and restart game
	addi $t9, $zero, 0								
	addi $t5, $zero, 0	
					
	endLoop:						#clear the buffer 
		add $t6, $t5, $s0				
		lb $t7, 0($t6)					
		beq $t7, 0, back
		sb $zero, 0($t6)
		addi $t5, $t5, 4
		j endLoop
		
	back:
		j wait
	
